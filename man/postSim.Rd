% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/postSim.R
\name{postSim}
\alias{postSim}
\title{Posterior simulation from a GAM object}
\usage{
postSim(o, nsim, newdata, fun = identity, method = "auto", w = NULL,
  offset = NULL, simplify = "rbind", ...)
}
\arguments{
\item{o}{the output of a \code{gam()} or \code{bam()} call.}

\item{nsim}{the number of simulated vectors of responses. A positive integer.}

\item{newdata}{Optional new data frame used to perform the simulations. To be passed to \link{predict.gam}.}

\item{fun}{function used to summarize each vector of simulated responses. It must take a vector as argument,
but it can output any type of object.}

\item{method}{the method used for the simulation of responses. See \link{simulate.gam}.}

\item{w}{vector of prior weights of each response. See \link{simulate.gam}.}

\item{offset}{numeric vector of offsets. For GAMs with multiple linear predictor (see eg \link{gaulss}) it
must be a list of vectors. If \code{newdat!=NULL} the offsets will be assumed to be zero,
unless their are explicitly provided. If \code{newdat==NULL} the simulations will use the
offsets used during model fitting, unless offset is explicitly provided.}

\item{simplify}{character string indicating the function that will be used to simplify the list of simulations.
It will be used in a call such as \code{do.call(simplify, listOfSimul)}. Set it to \code{NULL} to get
simply a list out.}

\item{...}{arguments to be passed to \link{vcov.gam}.}
}
\value{
A matrix where each row is a vector of simulated responses or a transformed version of it.
}
\description{
This method can be used to simulate vectors of responses from the
Gaussian posterior approximation of a gamObject.
}
\examples{
library(mgcViz)
library(MASS)
b <- gam(accel~s(times, k=20), data=mcycle)

# Simulate list of 10 vectors of responses from posterior
n <- 10
sim <- postSim(o = b, nsim = n)

# Posterior simulations in grey and data in red
plot(rep(mcycle$times, n), as.vector(t(sim)), col = "grey", 
     ylab = "Acceleration", xlab = "Times")
points(mcycle$times, mcycle$accel, col = 2)

# There is clear disagreement between simulations' and data's 
# conditional variance, which can be solved using flexible GAMLSS model:
b <- gam(list(accel~s(times, k=20), ~s(times)), data=mcycle, family = gaulss)
sim <- postSim(o = b, nsim = n)
plot(rep(mcycle$times, n), as.vector(t(sim)), col = "grey", 
     ylab = "Acceleration", xlab = "Times")
points(mcycle$times, mcycle$accel, col = 2)

}
